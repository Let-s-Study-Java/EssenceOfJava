## 14. 제네릭

목표 : 자바의 제네릭을 학습한다.

### **학습할 것**

- 제네릭 사용법
- 제네릭 주요 개념 (바운디드 타입, 와일드 카드)

---

<br/>

### 14-1. 제네릭 사용법

---

> 제네릭(Generics) : 다양한 타입의 객체를 다루는 메서드나 
컬렉션 클래스에 대해 컴파일 시 **타입 체크(compile-time type check)**를 해주는 기능

~~JDK 1.5에서 등장!~~

**" 제네릭 사용의 이점 "** 

1. 객체의 타입 안정성을 제공한다. → 타입 안정성을 높인다
    - 의도하지 않은 타입의 객체가 저장되는 것을 막는다.
    - 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다.
2. 타입체크와 형변환을 생략하여, 코드가 간결해 진다.
    - 실행 단계보다 컴파일 시에 타입체크를 하는 것이 더 좋다.
    - 따로 타입 변환을 할 필요가 없어져서 프로그램 성능이 향상된다.

**" 제네릭 클래스 선언 "**

```java
interface Box<T> {
	void box(T t); // void box(Object t);
	T unbox() {}; // void Object unbox() {};
}
```

- **Type Variable**
    - `Box<T>`의 T와 같은 문법은 타입 매개변수라는 특별한 이름으로 불린다.
    - `Map<String, Integer>`처럼 사용함으로써 타입 매개변수에 구체적인 값을 할당할 수 있다.
    - `T` : Type, `E` : Element, `K` : Key, `V` : Value 등 어떤 것을 사용하던 지네릭 타입으로 선언 가능하다.
    다만, 위 케이스들과 같이 상황에 맞게 의미있는 문자를 선택하여 사용하는 것이 중요하다.
    - 타입 매개변수의 값으로 Primitive Type이 올 수는 없다.
    - Java 7부터는 Diamond Syntax(`<>`)를 사용하여 컴파일러가 타입 파라미터를 유추해 자동으로 설정한다.

**" 제네릭 사용시 주의사항 "**

1. 모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T 를 사용할 수 없다.
    - T는 인스턴스 변수로, static은 인스턴스 변수를 참조할 수 없다.
2. 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다.

</br>

### 14-2. 제네릭 주요 개념 (바운디드 타입, 와일드 카드)

---

**" 바운디드 타입 "**

- 타입 파라미터들은 바운드(bound) 될 수 있다.

    → 바운드 된다는 의미는 제한된다는 의미이며, 메소드가 받을 수 있는 타입을 제한 할 수 있다는 뜻이다.

    ```java
    // Animal을 상속받은 모든 동물이 가능
    public <T extends Animal> List<T> fromArrayToList(T[] a) { ... }

    // 고양이의 상위 클래스만 가능
    public <T super Cat> List<T> fromArrayToList(T[] a) { ... }
    ```

    - 제네릭타입<T extends 상위타입> : 타입의 범위를 특정 객체의 하위클래스만 올 수 있다.
    - 제네릭타입<T super 하위타입> : 타입의 범위를 특정 객체의 상위클래스만 올 수 있다.

**" 다중 바운드 "** 

- 하나의 타입은 아래와 같이 상위의 여러 타입들을 상속받은 타입만 허용하도록 제한 할 수 있다.
- `<T extends Number & Comparable>` 타입 T 가 상속받은 타입이 클래스인 경우(Number 클래스를 상속 받는다면) 클래스 타입을 먼저 표기해야 한다. 순서가 바뀔경우 컴파일 오류가 발생한다.

**" 와일드 카드 "**

- Java에서 와일드 카드는 물음표 `?` 로 표시하며, 알 수 없는 타입을 의미할 때 사용된다.
- 특히 제네릭 타입을 사용할 때 유용하며, 파라미터로 사용될 수 있다.

</br>
